<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>码农求职记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="码农求职记">
<meta property="og:url" content="http://yoursite.com/">
<meta property="og:site_name" content="码农求职记">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码农求职记">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="码农求职记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<div class="profilepic">
			<img src="/img/me.jpeg">
		</div>

		<hgroup>
		  <h1 class="header-author"><a href="/">Zhang Yong</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Make things as simple as possible, but not simpler</p>
		
		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">所有文章</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
				<li><a href="/tags/二叉树">二叉树</a></li>
	        
				<li><a href="/tags/栈和队列">栈和队列</a></li>
	        
				<li><a href="/tags/排序">排序</a></li>
	        
			</ul>
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="/#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/2868793152" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="/#" title="rss">rss</a>
		        
			</div>
		</nav>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay"></div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/me.jpeg">
			</div>

			<hgroup>
			  <h1 class="header-author"><a href="/">Zhang Yong</a></h1>
			</hgroup>
			
			<p class="header-subtitle">Make things as simple as possible, but not simpler</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
					<li><a href="/tags/二叉树">二叉树</a></li>
		        
					<li><a href="/tags/栈和队列">栈和队列</a></li>
		        
					<li><a href="/tags/排序">排序</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/2868793152" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      
  
    <article id="post-populateNode" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/14/populateNode/" class="article-date">
  	<time datetime="2014-09-14T14:33:12.000Z" itemprop="datePublished">9月 14 2014</time>
</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/14/populateNode/">Populating Next Right Pointers in Each Node</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Given a binary tree</p>
<figure class="highlight"><pre>struct TreeLinkNode {
  TreeLinkNode <span class="variable">*left</span>;
  TreeLinkNode <span class="variable">*right</span>;
  TreeLinkNode <span class="variable">*next</span>;
}
</pre></figure><br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.<br><br>Initially, all next pointers are set to NULL.<br><br>Note:<br><br>You may only use constant extra space.<br>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<br>For example,<br>Given the following perfect binary tree,<br>         1<br>       /  \<br>      2    3<br>     / \  / \<br>    4  5  6  7<br>After calling your function, the tree should look like:<br>         1 -&gt; NULL<br>       /  \<br>      2 -&gt; 3 -&gt; NULL<br>     / \  / \<br>    4-&gt;5-&gt;6-&gt;7 -&gt; NULL<br><br><figure class="highlight"><pre><span class="literal">void</span> connect(TreeLinkNode <span class="subst">*</span>root) {
    <span class="keyword">while</span>(root){
        TreeLinkNode<span class="subst">*</span> prev <span class="subst">=</span> <span class="built_in">NULL</span>;<span class="comment">//previous node of the same level</span>
        TreeLinkNode<span class="subst">*</span> nxt <span class="subst">=</span> <span class="built_in">NULL</span>;<span class="comment">//first node of next level</span>
        
        for(; root; root <span class="subst">=</span> root<span class="subst">-&gt;</span>next){
            <span class="keyword">if</span>(<span class="subst">!</span>nxt) nxt <span class="subst">=</span> root<span class="subst">-&gt;</span>left <span class="subst">?</span> root<span class="subst">-&gt;</span>left : root<span class="subst">-&gt;</span>right;
            
            <span class="keyword">if</span>(root<span class="subst">-&gt;</span>left){
                <span class="keyword">if</span>(prev) prev<span class="subst">-&gt;</span>next <span class="subst">=</span> root<span class="subst">-&gt;</span>left;
                prev <span class="subst">=</span> root<span class="subst">-&gt;</span>left;
            }
            
            <span class="keyword">if</span>(root<span class="subst">-&gt;</span>right){
                <span class="keyword">if</span>(prev) prev<span class="subst">-&gt;</span>next <span class="subst">=</span> root<span class="subst">-&gt;</span>right;
                prev <span class="subst">=</span> root<span class="subst">-&gt;</span>right;
            }
        }
        
        root <span class="subst">=</span> nxt;
    }
}
</pre></figure>
      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-maxpathsum" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/14/maxpathsum/" class="article-date">
  	<time datetime="2014-09-14T14:31:57.000Z" itemprop="datePublished">9月 14 2014</time>
</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/14/maxpathsum/">Binary Tree Maximum Path Sum</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Given a binary tree, find the maximum path sum.</p>
<p>The path may start and end at any node in the tree.</p>
<p>For example:<br>Given the below binary tree,</p>
<p>[1,2,3]</p>
<p>Return 6.</p>
<figure class="highlight"><pre>int maxPathSum(TreeNode<span class="subst">*</span>root, int<span class="subst">&</span> maxSum){
    <span class="comment">//返回root路径，值最大的</span>
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;
    
    int left <span class="subst">=</span> maxPathSum(root<span class="subst">-&gt;</span>left,maxSum);
    int right <span class="subst">=</span> maxPathSum(root<span class="subst">-&gt;</span>right,maxSum);
    
    int <span class="keyword">sum</span> <span class="subst">=</span> root<span class="subst">-&gt;</span>val;
    
    <span class="keyword">if</span>(left <span class="subst">&gt;</span> <span class="number">0</span>) <span class="keyword">sum</span> <span class="subst">+=</span> left;
    <span class="keyword">if</span>(right <span class="subst">&gt;</span> <span class="number">0</span>) <span class="keyword">sum</span> <span class="subst">+=</span> right;
    
    maxSum <span class="subst">=</span> <span class="keyword">max</span>(maxSum,<span class="keyword">sum</span>);
    
    <span class="keyword">return</span> <span class="keyword">max</span>(left,right)<span class="subst">&gt;</span><span class="number">0</span> <span class="subst">?</span> root<span class="subst">-&gt;</span>val <span class="subst">+</span> <span class="keyword">max</span>(left,right) : root<span class="subst">-&gt;</span>val;

}

int maxPathSum(TreeNode <span class="subst">*</span>root) {
	int maxSum <span class="subst">=</span> INT_MIN;
	maxPathSum(root,maxSum);
	<span class="keyword">return</span> maxSum;
}
</pre></figure>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-pathsum2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/14/pathsum2/" class="article-date">
  	<time datetime="2014-09-14T14:30:19.000Z" itemprop="datePublished">9月 14 2014</time>
</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/14/pathsum2/">Path Sum II</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,</p>
<p>[5,4,8,11,#,13,4,7,2,5,1]</p>
<p>return<br>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
<figure class="highlight"><pre><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span> pathSum(TreeNode *root, <span class="keyword">int</span> sum) {
    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>tmp;
    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span>res;
    pathSum(root,res,tmp,sum);
    <span class="keyword">return</span> res;
}

<span class="keyword">void</span> pathSum(TreeNode* root,<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &gt;</span>& res, <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>& tmp, <span class="keyword">int</span> gap){
    <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span>;
    
    tmp.push_back(root-&gt;val);
    <span class="keyword">if</span>(!root-&gt;left && !root-&gt;right){<span class="comment">//叶子</span>
        <span class="keyword">if</span>(root-&gt;val == gap){
            res.push_back(tmp);
        }
    }
    
    pathSum(root-&gt;left,res,tmp,gap-root-&gt;val);
    pathSum(root-&gt;right,res,tmp,gap-root-&gt;val);
    
    tmp.pop_back();
}
</pre></figure>
      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-pathSum1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/14/pathSum1/" class="article-date">
  	<time datetime="2014-09-14T14:28:19.000Z" itemprop="datePublished">9月 14 2014</time>
</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/14/pathSum1/">Path Sum</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,</p>
<p>[5,4,8,11,#,13,4,7,2,#,#,#,1]</p>
<p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22</p>
<figure class="highlight"><pre>bool hasPathSum(TreeNode <span class="subst">*</span>root, int <span class="keyword">sum</span>) {
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;
    
    <span class="keyword">if</span>(<span class="subst">!</span>root<span class="subst">-&gt;</span>left <span class="subst">&&</span> <span class="subst">!</span>root<span class="subst">-&gt;</span>right) <span class="keyword">return</span> <span class="keyword">sum</span> <span class="subst">==</span> root<span class="subst">-&gt;</span>val;
    
    <span class="keyword">return</span> hasPathSum(root<span class="subst">-&gt;</span>left,<span class="keyword">sum</span><span class="attribute">-root</span><span class="subst">-&gt;</span>val) <span class="subst">||</span> hasPathSum(root<span class="subst">-&gt;</span>right,<span class="keyword">sum</span><span class="attribute">-root</span><span class="subst">-&gt;</span>val);
}
</pre></figure>
      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-maximum" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/14/maximum/" class="article-date">
  	<time datetime="2014-09-14T14:27:19.000Z" itemprop="datePublished">9月 14 2014</time>
</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/14/maximum/">Maximum Depth of Binary Tree</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<figure class="highlight"><pre><span class="comment">//Approach 1: </span>
<span class="keyword">int</span> maxDepth(TreeNode* root){
    <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">return</span> max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;
}

<span class="comment">//Approach 2:</span>
<span class="keyword">int</span> maxDepth(TreeNode *root) {
    <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="stl_container"><span class="built_in">queue</span>&lt;TreeNode*&gt;</span>que;
    <span class="stl_container"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;</span>height;
    que.push(root); height.push(<span class="number">1</span>);
    
    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;
    <span class="keyword">while</span>(!que.empty()){
        <span class="keyword">int</span> cnt = height.front();
        height.pop();
        TreeNode* p = que.front();
        que.pop();
        maxHeight = max(maxHeight,cnt);
        
        <span class="keyword">if</span>(p-&gt;left){
            que.push(p-&gt;left);
            height.push(cnt+<span class="number">1</span>);
        }
        <span class="keyword">if</span>(p-&gt;right){
            que.push(p-&gt;right);
            height.push(cnt+<span class="number">1</span>);
        }
    }
    <span class="keyword">return</span> maxHeight;
}
</pre></figure>
      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-minimumdepth" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/14/minimumdepth/" class="article-date">
  	<time datetime="2014-09-14T14:26:28.000Z" itemprop="datePublished">9月 14 2014</time>
</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/14/minimumdepth/">Minimum Depth of Binary Tree</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<figure class="highlight"><pre><span class="comment">//递归需要怎么做，你好好想想</span>
<span class="keyword">int</span> minDepth(TreeNode *root) {
   <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="number">0</span>;
   <span class="stl_container"><span class="built_in">queue</span>&lt;TreeNode*&gt;</span> que; que.push(root);
   <span class="stl_container"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;</span>height; height.push(<span class="number">1</span>);
   <span class="keyword">int</span> cnt = -<span class="number">1</span>;
   <span class="keyword">while</span>(!que.empty()){
       cnt = height.front();
       TreeNode* p = que.front();
       height.pop(); que.pop();
       
       <span class="keyword">if</span>(!p-&gt;left && !p-&gt;right) <span class="keyword">return</span> cnt;
       
       <span class="keyword">if</span>(p-&gt;left){
           que.push(p-&gt;left); 
           height.push(cnt+<span class="number">1</span>);
       }
       
       <span class="keyword">if</span>(p-&gt;right){
           que.push(p-&gt;right);
           height.push(cnt+<span class="number">1</span>);
       }
   }
   
   <span class="keyword">return</span> cnt;
}
</pre></figure>
      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-convert2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/14/convert2/" class="article-date">
  	<time datetime="2014-09-14T14:25:36.000Z" itemprop="datePublished">9月 14 2014</time>
</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/14/convert2/">Convert Sorted List to Binary Search Tree</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<figure class="highlight"><pre>TreeNode <span class="subst">*</span>sortedListToBST(ListNode <span class="subst">*</span>head) {
   <span class="keyword">if</span>(head <span class="subst">==</span> <span class="built_in">NULL</span>) <span class="keyword">return</span> <span class="built_in">NULL</span>;
   int n <span class="subst">=</span> getListLen(head);
   <span class="keyword">return</span> sortedListToBST(head,<span class="number">0</span>,n<span class="subst">-</span><span class="number">1</span>);
}

TreeNode<span class="subst">*</span> sortedListToBST1(ListNode<span class="subst">*</span> head, int l, int r){
    <span class="comment">//自顶而下，复杂度O(nlg(n))</span>
    <span class="keyword">if</span>(l<span class="subst">&gt;</span>r) <span class="keyword">return</span> <span class="built_in">NULL</span>;
    
    int mid <span class="subst">=</span> l <span class="subst">+</span> (r<span class="attribute">-l</span>)/<span class="number">2</span>;
    ListNode<span class="subst">*</span> pt <span class="subst">=</span> head;
    
    for(int i<span class="subst">=</span>l; i<span class="subst">&lt;</span>mid; i<span class="subst">++</span>) pt <span class="subst">=</span> pt<span class="subst">-&gt;</span>next;
    
    TreeNode<span class="subst">*</span> root <span class="subst">=</span> <span class="literal">new</span> TreeNode(pt<span class="subst">-&gt;</span>val);
    root<span class="subst">-&gt;</span>left <span class="subst">=</span> sortedListToBST(head,l,mid<span class="subst">-</span><span class="number">1</span>);
    root<span class="subst">-&gt;</span>right <span class="subst">=</span> sortedListToBST(pt<span class="subst">-&gt;</span>next,mid<span class="subst">+</span><span class="number">1</span>,r);
    
    <span class="keyword">return</span> root;
}

TreeNode<span class="subst">*</span> sortedListToBST2(ListNode<span class="subst">*</span> <span class="subst">&</span>head, int l, int r){<span class="comment">//&head,引用精髓</span>
    <span class="keyword">if</span>(l<span class="subst">&gt;</span>r) <span class="keyword">return</span> <span class="built_in">NULL</span>;
    
    <span class="comment">//Apprach 2: 自底而上,复杂度O(n)</span>
    int mid <span class="subst">=</span> l <span class="subst">+</span> (r<span class="attribute">-l</span>)/<span class="number">2</span>;
    TreeNode<span class="subst">*</span> left <span class="subst">=</span> sortedListToBST(head,l,mid<span class="subst">-</span><span class="number">1</span>);<span class="comment">//运行完，head指向中间位</span>
    TreeNode<span class="subst">*</span> root <span class="subst">=</span> <span class="literal">new</span> TreeNode(head<span class="subst">-&gt;</span>val);
    root<span class="subst">-&gt;</span>left <span class="subst">=</span> left;
    head <span class="subst">=</span> head<span class="subst">-&gt;</span>next;<span class="comment">//必须要有</span>
    root<span class="subst">-&gt;</span>right <span class="subst">=</span> sortedListToBST(head,mid<span class="subst">+</span><span class="number">1</span>,r);
    
    <span class="keyword">return</span> root;
}

int getListLen(ListNode<span class="subst">*</span> head){
    <span class="keyword">if</span>(head <span class="subst">==</span> <span class="built_in">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;
    int len <span class="subst">=</span> <span class="number">0</span>;
    <span class="keyword">while</span>(head){
        head <span class="subst">=</span> head<span class="subst">-&gt;</span>next;
        len<span class="subst">++</span>;
    }
    
    <span class="keyword">return</span> len;
}
</pre></figure>
      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-convert1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/14/convert1/" class="article-date">
  	<time datetime="2014-09-14T14:24:44.000Z" itemprop="datePublished">9月 14 2014</time>
</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/14/convert1/">Convert Sorted Array to Binary Search Tree</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<figure class="highlight"><pre>TreeNode *sortedArrayToBST(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &num) {
    <span class="keyword">if</span>(num.size() == <span class="number">0</span>) <span class="keyword">return</span> NULL;
    <span class="keyword">return</span> sortedArrayToBST(num,<span class="number">0</span>,num.size()-<span class="number">1</span>);
}

TreeNode* sortedArrayToBST(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>& num, <span class="keyword">int</span> l, <span class="keyword">int</span> r){
    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> NULL;
    
    <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;
    TreeNode* root = <span class="keyword">new</span> TreeNode(num[mid]);
    root-&gt;left = sortedArrayToBST(num,l,mid-<span class="number">1</span>);
    root-&gt;right = sortedArrayToBST(num,mid+<span class="number">1</span>,r);
    
    <span class="keyword">return</span> root;
}`
</pre></figure>
      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-validBST" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/14/validBST/" class="article-date">
  	<time datetime="2014-09-14T14:23:38.000Z" itemprop="datePublished">9月 14 2014</time>
</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/14/validBST/">Validate Binary Search Tree</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ.</p>
<figure class="highlight"><pre>bool isValidBST(TreeNode<span class="subst">*</span> root, int lower, int upper){
    <span class="keyword">if</span>(root <span class="subst">==</span> <span class="built_in">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;
    
    <span class="keyword">return</span> root<span class="subst">-&gt;</span>val <span class="subst">&lt;</span> upper <span class="subst">&&</span> root<span class="subst">-&gt;</span>val <span class="subst">&gt;</span> lower
         <span class="subst">&</span> isValidBST(root<span class="subst">-&gt;</span>left,lower,root<span class="subst">-&gt;</span>val)
         <span class="subst">&</span> isValidBST(root<span class="subst">-&gt;</span>right,root<span class="subst">-&gt;</span>val,upper);
}

bool isValidBST(TreeNode <span class="subst">*</span>root) {
   <span class="keyword">return</span> isValidBST(root,INT_MIN,INT_MAX);     
}
</pre></figure>


      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-unique2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/14/unique2/" class="article-date">
  	<time datetime="2014-09-14T14:21:17.000Z" itemprop="datePublished">9月 14 2014</time>
</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/14/unique2/">Unique Binary Search Trees II</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For example,<br>Given n = 3, your program should return all 5 unique BST’s shown below.</p>
<p>[1,#,3,2], [3,2,#,1], [3,1,#,#,2], [2,1,3], [1,#,2,#,3]</p>
<p>confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ.</p>
<figure class="highlight"><pre><span class="stl_container"><span class="built_in">vector</span>&lt;TreeNode *&gt;</span> generateTrees(<span class="keyword">int</span> n) {
    <span class="keyword">return</span> generate(<span class="number">1</span>,n);
}
    
<span class="stl_container"><span class="built_in">vector</span>&lt;TreeNode*&gt;</span> generate(<span class="keyword">int</span> l, <span class="keyword">int</span> r){
    <span class="stl_container"><span class="built_in">vector</span>&lt;TreeNode*&gt;</span>res;
        
    <span class="keyword">if</span>(l&gt;r){
        res.push_back(NULL);
        <span class="keyword">return</span> res;
    }
        
    <span class="keyword">for</span>(<span class="keyword">int</span> k=l; k &lt;= r; k++){
        <span class="stl_container"><span class="built_in">vector</span>&lt;TreeNode*&gt;</span> left = generate(l,k-<span class="number">1</span>);
        <span class="stl_container"><span class="built_in">vector</span>&lt;TreeNode*&gt;</span> right = generate(k+<span class="number">1</span>,r);
            
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;left.size(); i++){
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;right.size(); j++){
                TreeNode* root = <span class="keyword">new</span> TreeNode(k);
                root-&gt;left = left[i];
                root-&gt;right = right[j];
                res.push_back(root);
            }
        }
    }
    
    <span class="keyword">return</span> res;
}
</pre></figure>
      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  

      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2014 Zhang Yong
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>

  </div>
</body>
</html>