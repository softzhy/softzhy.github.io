<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 2 | 码农求职记</title>
  <meta name="author" content="Zhang Yong">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="码农求职记"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">码农求职记</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/homepage" title="About me.">
			  <i class="fa fa-user"></i>Homepage
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header">
  <h1>Make things as simple as possible, but not simpler</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      Make things as simple as possible, but not simpler.
</div>    

		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
		<h3 class="title">
			<a href="/2014/09/14/uniqueBinary/" >Unique Binary Search Trees</a>
			<span class="date"> 9月 14 2014 </span>
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>
<p>[1,#,3,2], [3,2,#,1], [3,1,#,#,2], [2,1,3], [1,#,2,#,3]</p>
<figure class="highlight"><pre><span class="keyword">int</span> numTrees(<span class="keyword">int</span> n) {
    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>dp(n+<span class="number">1</span>,<span class="number">0</span>);
    dp[<span class="number">0</span>] = <span class="number">1</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= n; i++){
        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;i; k++){
            dp[i] += dp[k] * dp[i-k-<span class="number">1</span>];
        }
    }
    
    <span class="keyword">return</span> dp[n];
}
</pre></figure>
	
	</div>
	
  
</div>
	<a type="button" href="/2014/09/14/uniqueBinary/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
		<h3 class="title">
			<a href="/2014/09/14/constructPI/" >Construct Binary Tree from Preorder and Inorder Traversal</a>
			<span class="date"> 9月 14 2014 </span>
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<figure class="highlight"><pre>TreeNode* generateTree(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>& preorder, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>& inOrder, <span class="keyword">int</span> il, <span class="keyword">int</span> ir){
    <span class="keyword">if</span>(pl&gt;pr) <span class="keyword">return</span> NULL;<span class="comment">//&gt; not &gt;=</span>
    
    TreeNode* tmp = <span class="keyword">new</span> TreeNode(preorder[pl]);
    <span class="keyword">int</span> mid = il;
    <span class="keyword">while</span>(inOrder[mid] != preorder[pl]) mid++;<span class="comment">//分两半</span>
    <span class="keyword">int</span> len = mid - il;
    
    tmp-&gt;left = generateTree(preorder,pl+<span class="number">1</span>,pl+len,inOrder,il,mid-<span class="number">1</span>);
    tmp-&gt;right = generateTree(preorder,pl+len+<span class="number">1</span>,pr,inOrder,mid+<span class="number">1</span>,ir);
    
}
    
TreeNode *buildTree(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &preorder, <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &inorder) {
    <span class="keyword">if</span>(preorder.size() == <span class="number">0</span>) <span class="keyword">return</span> NULL;
    <span class="keyword">int</span> n = preorder.size()-<span class="number">1</span>;
    <span class="keyword">return</span> generateTree(preorder,<span class="number">0</span>,n,inorder,<span class="number">0</span>,n);
}
</pre></figure>
	
	</div>
	
  
</div>
	<a type="button" href="/2014/09/14/constructPI/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
		<h3 class="title">
			<a href="/2014/09/14/construct/" >Construct Binary Tree from Inorder and Postorder Traversal</a>
			<span class="date"> 9月 14 2014 </span>
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<figure class="highlight"><pre>TreeNode *buildTree(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &inorder, <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &postorder) {
    <span class="keyword">if</span>(inorder.size() == <span class="number">0</span>) <span class="keyword">return</span> NULL;
    <span class="keyword">int</span> n = inorder.size()-<span class="number">1</span>;
    <span class="keyword">return</span> generateTree(inorder,<span class="number">0</span>,n,postorder,<span class="number">0</span>,n);
}

TreeNode* generateTree(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>& inOrder, <span class="keyword">int</span> il, <span class="keyword">int</span> ir, <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>& postOrder, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr){
    <span class="keyword">if</span>(il&gt;ir) <span class="keyword">return</span> NULL;
    
    TreeNode* tmp = <span class="keyword">new</span> TreeNode(postOrder[pr]);
    <span class="keyword">int</span> mid = il;
    <span class="keyword">while</span>(inOrder[mid] != postOrder[pr]) mid++;
    <span class="keyword">int</span> len = mid - il;
    
    tmp-&gt;left = generateTree(inOrder,il,mid-<span class="number">1</span>,postOrder,pl,pl+len-<span class="number">1</span>);
    tmp-&gt;right = generateTree(inOrder,mid+<span class="number">1</span>,ir,postOrder,pl+len,pr-<span class="number">1</span>);
}
</pre></figure>

	
	</div>
	
  
</div>
	<a type="button" href="/2014/09/14/construct/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
		<h3 class="title">
			<a href="/2014/09/14/sortcol/" >Sort Colors</a>
			<span class="date"> 9月 14 2014 </span>
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note:<br>You are not suppose to use the library’s sort function for this problem.</p>
<p>click to show follow up.</p>
<p>Follow up:<br>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</p>
<p>Could you come up with an one-pass algorithm using only constant space?</p>
<figure class="highlight"><pre><span class="keyword">void</span> sortColors(<span class="keyword">int</span> A[], <span class="keyword">int</span> n) {
    <span class="keyword">int</span> <span class="keyword">count</span>[<span class="number">3</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};
    
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">count</span>[A[i]]++;
    
    <span class="keyword">int</span> <span class="keyword">index</span> = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++){
        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="keyword">count</span>[i]; j++)
            A[<span class="keyword">index</span>++] = i;
    }
}
</pre></figure>
	
	</div>
	
  
</div>
	<a type="button" href="/2014/09/14/sortcol/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
		<h3 class="title">
			<a href="/2014/09/14/firstmissingpositive/" >First Missing Positive</a>
			<span class="date"> 9月 14 2014 </span>
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br>Given [1,2,0] return 3,<br>and [3,4,-1,1] return 2.</p>
<p>Your algorithm should run in O(n) time and uses constant space.</p>
<figure class="highlight"><pre><span class="comment">//符合要求的做法，需要好好研究下</span>
<span class="keyword">int</span> firstMissingPositive(<span class="keyword">int</span> A[], <span class="keyword">int</span> n) {
    <span class="comment">//数组本身做哈希表</span>
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++){
        <span class="comment">//A[i]的值对应 i+1</span>
        <span class="keyword">while</span>(A[i] != i+<span class="number">1</span>){<span class="comment">//while精髓</span>
            <span class="keyword">if</span>(A[i] &lt;= <span class="number">0</span> || A[i] &gt; n || A[i] == A[A[i]-<span class="number">1</span>])
                <span class="keyword">break</span>;
            swap(A[i],A[A[i]-<span class="number">1</span>]);
        }
    } 
    
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++){
        <span class="keyword">if</span>(A[i] != i+<span class="number">1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;
    }
    
    <span class="keyword">return</span> n+<span class="number">1</span>;
}

<span class="comment">//数据结构set</span>
<span class="keyword">int</span> firstMissingPositive(<span class="keyword">int</span> A[], <span class="keyword">int</span> n) {
    <span class="stl_container"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;</span>st;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++){
        <span class="keyword">if</span>(A[i]&gt;<span class="number">0</span>) st.insert(A[i]);
    }
    
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= n+<span class="number">1</span>; i++){
        <span class="keyword">if</span>(st.find(i) == st.end()) <span class="keyword">return</span> i;
    }
}
</pre></figure>
	
	</div>
	
  
</div>
	<a type="button" href="/2014/09/14/firstmissingpositive/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
		<h3 class="title">
			<a href="/2014/09/14/sortlist2/" >Sort List</a>
			<span class="date"> 9月 14 2014 </span>
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<figure class="highlight"><pre>ListNode* sortList(ListNode <span class="variable">*head</span>) {
    <span class="keyword">if</span>(head == NULL || head-&gt;<span class="keyword">next</span> == NULL) <span class="keyword">return</span> head;
    
    ListNode* prev = NULL, <span class="variable">*slow</span> = head, <span class="variable">*fast</span> = head;
    
    <span class="keyword">while</span>(fast && fast-&gt;<span class="keyword">next</span>){
        prev = slow;
        slow = slow-&gt;<span class="keyword">next</span>;
        fast = fast-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;
    }
    
    //<span class="keyword">split</span>
    prev-&gt;<span class="keyword">next</span> = NULL;
    
    ListNode* left = sortList(head);
    ListNode* right = sortList(slow);
    
    <span class="keyword">return</span> merge(left,right);
}

ListNode* merge(ListNode* left, ListNode* right){
    ListNode* ret = NULL;
    ListNode<span class="variable">**</span> pCur = &ret;
    
    <span class="keyword">while</span>(left && right){
        <span class="keyword">if</span>(left-&gt;val &lt; right-&gt;val){
            <span class="variable">*pCur</span> = left;
            left = left-&gt;<span class="keyword">next</span>;
        }
        <span class="keyword">else</span>{
            <span class="variable">*pCur</span> = right;
            right = right-&gt;<span class="keyword">next</span>;
        }
        
        pCur = &((<span class="variable">*pCur</span>)-&gt;<span class="keyword">next</span>);
    }
    
    <span class="keyword">while</span>(right){
        <span class="variable">*pCur</span> = right;
        pCur = &((<span class="variable">*pCur</span>)-&gt;<span class="keyword">next</span>);
        right = right-&gt;<span class="keyword">next</span>;
    }
    
    <span class="keyword">while</span>(left){
        <span class="variable">*pCur</span> = left;
        pCur = &((<span class="variable">*pCur</span>)-&gt;<span class="keyword">next</span>);
        left = left-&gt;<span class="keyword">next</span>;
    }
    
    <span class="variable">*pCur</span> = NULL;
    
    <span class="keyword">return</span> ret;
}
</pre></figure>
	
	</div>
	
  
</div>
	<a type="button" href="/2014/09/14/sortlist2/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
		<h3 class="title">
			<a href="/2014/09/14/insertlist/" >Insertion Sort List</a>
			<span class="date"> 9月 14 2014 </span>
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>Sort a linked list using insertion sort.</p>
<figure class="highlight"><pre>ListNode <span class="variable">*insertionSortList</span>(ListNode <span class="variable">*head</span>) {
    ListNode* ret = NULL;
    ListNode<span class="variable">**</span> pCur = &ret;
    ListNode* temp = head, <span class="variable">*nxt</span> = NULL;
    
    <span class="keyword">while</span>(temp){
        pCur = &ret;
        <span class="keyword">while</span>(<span class="variable">*pCur</span> && (<span class="variable">*pCur</span>)-&gt;val &lt;= temp-&gt;val){
            pCur = &((<span class="variable">*pCur</span>)-&gt;<span class="keyword">next</span>);
        }
        
        nxt = temp-&gt;<span class="keyword">next</span>;
        temp-&gt;<span class="keyword">next</span> = <span class="variable">*pCur</span>;
        <span class="variable">*pCur</span> = temp;
        temp = nxt;
    }
    
    <span class="keyword">return</span> ret;
}
</pre></figure>
	
	</div>
	
  
</div>
	<a type="button" href="/2014/09/14/insertlist/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
		<h3 class="title">
			<a href="/2014/09/14/mergeklists/" >Merge k Sorted Lists</a>
			<span class="date"> 9月 14 2014 </span>
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<figure class="highlight"><pre>ListNode *mergeKLists(<span class="stl_container"><span class="built_in">vector</span>&lt;ListNode* &gt;</span> &lists) { 
    <span class="keyword">if</span>(lists.size() == <span class="number">0</span>) <span class="keyword">return</span> NULL;
   
    <span class="comment">//默认最大堆，队首是最大元素，重载的&lt;号，&gt;号编译不通过</span>
    priority_queue&lt;ListNode*, <span class="stl_container"><span class="built_in">vector</span>&lt;ListNode*&gt;</span>, cmp&gt; que;
	
	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lists.size(); i++){
        <span class="keyword">if</span>(lists[i] != NULL) que.push(lists[i]);<span class="comment">//非空才加入</span>
	}
	
	ListNode* ret = NULL;
	ListNode** pCur = &ret;
	
	<span class="keyword">while</span>(!que.empty()){
	    ListNode* p = que.top();
	    *pCur = p;
	    pCur = &((*pCur)-&gt;next);
	    que.pop();
	    
	    <span class="keyword">if</span>(p-&gt;next != NULL) que.push(p-&gt;next);
	}
	
	*pCur = NULL;
	
	<span class="keyword">return</span> ret;
}

<span class="keyword">struct</span> cmp{
    <span class="keyword">bool</span> <span class="keyword">operator</span>() (ListNode* a, ListNode* b){<span class="comment">//反其道而行</span>
        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;<span class="comment">//这样变成最小堆</span>
    }
};
</pre></figure>
	
	</div>
	
  
</div>
	<a type="button" href="/2014/09/14/mergeklists/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
		<h3 class="title">
			<a href="/2014/09/14/mergetwosortedlists/" >Merge Two Sorted Lists</a>
			<span class="date"> 9月 14 2014 </span>
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<figure class="highlight"><pre>ListNode <span class="variable">*mergeTwoLists</span>(ListNode <span class="variable">*l1</span>, ListNode <span class="variable">*l2</span>) {
    ListNode* ret = NULL;
    ListNode<span class="variable">**</span> pCur = &ret;
    
    <span class="keyword">while</span>(l1 && l2){
        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val){
            <span class="variable">*pCur</span> = l1; 
            l1 = l1-&gt;<span class="keyword">next</span>;
        }
        <span class="keyword">else</span>{
            <span class="variable">*pCur</span> = l2;
            l2 = l2-&gt;<span class="keyword">next</span>;
        }
        
        pCur = &((<span class="variable">*pCur</span>)-&gt;<span class="keyword">next</span>);
    }
    
    <span class="keyword">while</span>(l1){
        <span class="variable">*pCur</span> = l1;
        l1 = l1-&gt;<span class="keyword">next</span>;
        pCur = &((<span class="variable">*pCur</span>)-&gt;<span class="keyword">next</span>);

    }
    
    <span class="keyword">while</span>(l2){
        <span class="variable">*pCur</span> = l2;
        l2 = l2-&gt;<span class="keyword">next</span>;
        pCur = &((<span class="variable">*pCur</span>)-&gt;<span class="keyword">next</span>);

    }
    
    <span class="variable">*pCur</span> = NULL;
    
    <span class="keyword">return</span> ret;
}
</pre></figure>
	
	</div>
	
  
</div>
	<a type="button" href="/2014/09/14/mergetwosortedlists/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
		<h3 class="title">
			<a href="/2014/09/14/mergeSortedArray/" >Merge Sorted Array</a>
			<span class="date"> 9月 14 2014 </span>
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>Merge Sorted Array Total Accepted: 22608 Total Submissions: 70282 My Submissions<br>Given two sorted integer arrays A and B, merge B into A as one sorted array.</p>
<p>Note:<br>You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B. The number of elements initialized in A and B are m and n respectively.</p>
<figure class="highlight"><pre>void merge(<span class="built_in">int</span> A[], <span class="built_in">int</span> m, <span class="built_in">int</span> B[], <span class="built_in">int</span> n) {
    <span class="built_in">int</span> <span class="built_in">len</span> = m+n-<span class="number">1</span>;
    <span class="built_in">int</span> ia = m-<span class="number">1</span>, ib = n-<span class="number">1</span>;
    
    <span class="keyword">while</span>(ia &gt;=<span class="number">0</span> && ib &gt;= <span class="number">0</span>){
        A[<span class="built_in">len</span>--] = A[ia] &gt; B[ib] ? A[ia--] : B[ib--];
    }
    
    <span class="keyword">while</span>(ib &gt;= <span class="number">0</span>) A[<span class="built_in">len</span>--] = B[ib--];
}
</pre></figure>

	
	</div>
	
  
</div>
	<a type="button" href="/2014/09/14/mergeSortedArray/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> Prev</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/3/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			<div class="form-group has-success has-feedback">
  <form action="//google.com/search" method="get" accept-charset="utf-8" >
    <input type="search" name="q" results="0" placeholder="Search" class="form-control">
    <input type="hidden" name="q" value="site:yoursite.com">	
  </form>
</div>

		
			
		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/栈和队列/">栈和队列<span>1</span></a></li>
		
			<li><a href="/tags/二叉树/">二叉树<span>16</span></a></li>
		
			<li><a href="/tags/排序/">排序<span>7</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2014/09/14/populateNode/" ><i class="fa fa-file-o"></i>Populating Next Right Point...</a>
      </li>
    
      <li>
        <a href="/2014/09/14/maxpathsum/" ><i class="fa fa-file-o"></i>Binary Tree Maximum Path Sum</a>
      </li>
    
      <li>
        <a href="/2014/09/14/pathsum2/" ><i class="fa fa-file-o"></i>Path Sum II</a>
      </li>
    
      <li>
        <a href="/2014/09/14/pathSum1/" ><i class="fa fa-file-o"></i>Path Sum</a>
      </li>
    
      <li>
        <a href="/2014/09/14/maximum/" ><i class="fa fa-file-o"></i>Maximum Depth of Binary Tree</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/freemind/" title="Freemind's Github repository." target="_blank"]);">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/softzhy" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class="fa fa-linkedin"></i><a href="http://www.linkedin.com/pub/weizhou-pan/5b/8a0/161" title="My Linkin account." target="_blank"]);">My LinkedIn</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2014 Zhang Yong
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>


<script type="text/javascript">
  var duoshuoQuery = { short_name: '如何文艺' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
   </html>
